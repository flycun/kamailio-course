# 设置RTP响应路由
# 处理SIP响应消息中的RTP媒体流管理，确保媒体路径一致性
route[SET_RTP_REPLY] {
    xlog("L_INFO", "SET_RTP_REPLY | ENTERING ROUTE BLOCK\n");
    
    # 处理包含SDP内容的响应消息
    if (sdp_content()) {
        # 保存原始SDP内容
        $avp(originalSDP) = $rb;
        
        # 处理来自公共网络的响应
        if(isflagset(FLT_FROM_PUBLIC)){

            # TLS协议处理：启用SRTP加密
            if (proto==TLS) {
                xlog("L_INFO", "SET_RTP_REPLY | proto is TLS!  \n");
				# RTP/SAVP: 启用SRTP加密
                # replace-origin: 替换SDP源地址
                # replace-session-connection: 替换会话连接信息
                # SIP-source-address: 使用SIP源地址
                # ICE=remove: 移除ICE相关信息
                # direction=public和direction=core: 设置媒体流方向
				rtpengine_manage("RTP/SAVP replace-origin replace-session-connection SIP-source-address ICE=remove direction=public direction=core");
            }

            xlog("L_INFO", "SET_RTP_REPLY | FROM_PUBLIC IS SET\n");
            # 标准SDP处理，设置媒体流方向：public→core
            rtpengine_manage("replace-origin replace-session-connection direction=public direction=core");
        }
        
        # 处理来自核心网络的响应
        if(isflagset(FLT_FROM_CORE)){
            xlog("L_INFO", "SET_RTP_REPLY | FROM_CORE IS SET\n");
            # 标准SDP处理，设置媒体流方向：core→public
            rtpengine_manage("replace-origin replace-session-connection direction=core direction=public");
        }            
        
        # 设置修改后的SDP内容
        set_body("$avp(modifiedSDP)","application/sdp");
    }

    # 处理错误响应(3xx-6xx)
    if ($rs=~"[3-6][0-9][0-9]") {
        # 执行基本的RTP引擎管理
        rtpengine_manage();
    }
}