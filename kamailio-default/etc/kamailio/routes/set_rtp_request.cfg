# RTP请求处理路由
# 根据消息来源和协议类型管理媒体流，实现安全边界处理
# 1. 外部网络(TLS/SRTP) → 内部网络(普通RTP): 解密处理
# 2. 内部网络 → 外部网络: 根据用户注册状态决定是否加密
route[SET_RTP_REQUEST] {
    # 检查方法是否为UPDATE或INVITE
	if (!is_method("UPDATE|INVITE")) {
        return 0;
	}
    if (sdp_content()) {
        # 保存原始SDP内容
        $avp(originalSDP) = $rb;

        # 处理来自公共网络(外部)的消息
        if(isflagset(FLT_FROM_PUBLIC)){
            xlog("L_INFO", "SET_RTP_REQUEST | FROM_PUBLIC IS SET |  PROTO = $proto \n");
            # 如果协议是TLS，转换为内部网络的普通RTP
            if (proto==TLS) {
                xlog("L_INFO", "SET_RTP_REQUEST | proto is TLS! Convert to unencrypted RTP in the core \n");
				# RTP/AVP: 转换为普通RTP
                # replace-origin: 替换SDP源地址
                # replace-session-connection: 替换会话连接信息
                # SIP-source-address: 使用SIP源地址
                # ICE=remove: 移除ICE相关信息
                # direction=public和direction=core: 设置媒体流方向
				rtpengine_manage("RTP/AVP replace-origin replace-session-connection SIP-source-address ICE=remove direction=public direction=core");
            }
        }

        # 处理来自核心网络(内部)的消息
        if(isflagset(FLT_FROM_CORE)){
            xlog("L_INFO", "SET_RTP_REQUEST | FROM_CORE IS SET\n");
            # 检查远程用户是否已注册
            if(reg_fetch_contacts("location", "$ru", "caller")) {
                # 对于已注册用户，使用SRTP加密媒体流
                xlog("L_INFO", "SET_RTP_REQUEST | REGISTERED USER FOUND - Using SRTP\n");
                # RTP/SAVP: 启用SRTP加密
                rtpengine_manage("RTP/SAVP replace-origin replace-session-connection direction=core direction=public");
            } else { 
                # 对于未注册用户，使用普通RTP媒体流
                xlog("L_INFO", "SET_RTP_REQUEST | Non registered device: Using unecrypted RTP \n");
                rtpengine_manage("replace-origin replace-session-connection direction=core direction=public");
            }
        set_body("$avp(modifiedSDP)","application/sdp");      
    }       
  } 
}
